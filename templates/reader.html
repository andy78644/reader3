<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

        /* Chat Sidebar */
        #chat-sidebar {
            width: 380px;
            min-width: 280px;
            max-width: 600px;
            background: #ffffff;
            border-left: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: margin-right 0.3s ease;
            position: relative;
        }
        #chat-sidebar.collapsed {
            margin-right: calc(-1 * var(--chat-width, 380px));
        }
        #chat-sidebar.resizing {
            transition: none;
        }

        /* Chat Toggle Button */
        .chat-toggle {
            position: fixed;
            right: 20px;
            top: 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        .chat-toggle:hover {
            background: #2980b9;
            transform: scale(1.1);
        }
        .chat-toggle.active {
            background: #e74c3c;
        }

        /* Chat Resizer */
        .chat-resizer {
            position: absolute;
            left: 0;
            top: 0;
            width: 5px;
            height: 100%;
            cursor: ew-resize;
            background: transparent;
            transition: background 0.2s ease;
            z-index: 10;
        }
        .chat-resizer:hover {
            background: #3498db;
        }
        .chat-resizer.resizing {
            background: #2980b9;
        }

        /* Chat Header */
        .chat-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            font-family: -apple-system, sans-serif;
        }
        .chat-header h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-header .clear-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: background 0.2s;
        }
        .chat-header .clear-btn:hover {
            background: #c82333;
        }

        /* Settings Section */
        .chat-settings {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }
        .chat-settings input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: -apple-system, sans-serif;
            box-sizing: border-box;
        }
        .chat-settings button {
            margin-top: 8px;
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-family: -apple-system, sans-serif;
        }
        .chat-settings button:hover {
            background: #218838;
        }
        .settings-status {
            margin-top: 8px;
            font-size: 0.8em;
            color: #6c757d;
        }

        /* Chat Messages */
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            font-family: -apple-system, sans-serif;
        }
        .chat-message {
            margin-bottom: 16px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .chat-message.user {
            text-align: right;
        }
        .chat-message .message-bubble {
            display: inline-block;
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .chat-message.user .message-bubble {
            background: #3498db;
            color: white;
            text-align: left;
        }
        .chat-message.ai .message-bubble {
            background: #f1f3f5;
            color: #212529;
            text-align: left;
        }
        .chat-message.system .message-bubble {
            background: #fff3cd;
            color: #856404;
            text-align: center;
            font-size: 0.85em;
        }

        /* Chat Input */
        .chat-input-container {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: #f8f9fa;
        }
        .chat-input-form {
            display: flex;
            gap: 10px;
        }
        .chat-input-form textarea {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: -apple-system, sans-serif;
            resize: none;
            height: 60px;
        }
        .chat-input-form button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
        }
        .chat-input-form button:hover {
            background: #2980b9;
        }
        .chat-input-form button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .chat-input-form button.loading {
            background: #95a5a6;
            position: relative;
        }
        .chat-input-form button.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spinner 0.6s linear infinite;
        }
        @keyframes spinner {
            to { transform: rotate(360deg); }
        }

        /* Timeout settings */
        .timeout-indicator {
            font-size: 0.75em;
            color: #6c757d;
            margin-top: 4px;
            text-align: center;
        }

        /* Text Selection Indicator */
        .selection-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: #e3f2fd;
            border-bottom: 2px solid #3498db;
            padding: 10px 16px;
            font-family: -apple-system, sans-serif;
            font-size: 0.85em;
            color: #1976d2;
            display: none;
            text-align: center;
            z-index: 5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .selection-indicator.active {
            display: block;
        }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- CHAT SIDEBAR -->
    <div id="chat-sidebar" class="collapsed">
        <div class="chat-resizer" id="chat-resizer"></div>

        <!-- Selection Indicator -->
        <div class="selection-indicator" id="selection-indicator">
            <span class="selection-indicator-text" id="selection-indicator-text">üìù Â∑≤ÈÅ∏Âèñ 0 Â≠ó - Âú®‰∏ãÊñπËº∏ÂÖ•ÂïèÈ°åÂç≥ÂèØË®éË´ñÊ≠§ÊÆµËêΩ</span>
        </div>

        <div class="chat-header">
            <h3>
                <span>üí¨ AI ËÅäÂ§©Âä©Êâã</span>
                <button class="clear-btn" onclick="clearChatHistory()" title="Ê∏ÖÈô§Ê≠§Êõ∏ÁöÑËÅäÂ§©Ë®òÈåÑ">Ê∏ÖÈô§Ë®òÈåÑ</button>
            </h3>
            <div class="chat-settings">
                <input type="password" id="api-key-input" placeholder="Ëº∏ÂÖ• Gemini API Key" />
                <button onclick="saveApiKey()">ÂÑ≤Â≠ò API Key</button>
                <div class="settings-status" id="settings-status"></div>

                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #dee2e6;">
                    <label for="model-select" style="display: block; margin-bottom: 6px; font-size: 0.85em; color: #6c757d;">ÈÅ∏ÊìáÊ®°ÂûãÔºö</label>
                    <select id="model-select" onchange="saveModelSelection()" style="width: 100%; padding: 6px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.85em; font-family: -apple-system, sans-serif;">
                        <option value="gemini-2.5-flash">Gemini 2.5 FlashÔºàÊé®Ëñ¶Ôºâ</option>
                        <option value="gemini-2.5-pro">Gemini 2.5 ProÔºàÊõ¥Âº∑Â§ßÔºâ</option>
                        <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                        <option value="gemini-3-pro-preview">Gemini 3.0 ProÔºàÂØ¶È©óÁâàÔºâ</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            <div class="chat-message system">
                <div class="message-bubble">
                    Ê≠°Ëøé‰ΩøÁî® AI ËÅäÂ§©Âä©ÊâãÔºÅË´ãÂÖàË®≠ÂÆö Gemini API KeyÔºåÁÑ∂ÂæåÂ∞±ÂèØ‰ª•ÈñãÂßãË®éË´ñÈÄôÊú¨Êõ∏‰∫Ü„ÄÇ
                </div>
            </div>
        </div>

        <div class="chat-input-container">
            <form class="chat-input-form" onsubmit="sendMessage(event)">
                <textarea id="chat-input" placeholder="ÂïèÊàëÈóúÊñºÈÄôÊú¨Êõ∏ÁöÑ‰ªª‰ΩïÂïèÈ°å..." required></textarea>
                <button type="submit" id="send-btn">ÁôºÈÄÅ</button>
            </form>
            <div class="timeout-indicator" id="timeout-indicator"></div>
        </div>
    </div>

    <!-- Chat Toggle Button -->
    <button class="chat-toggle" onclick="toggleChat()" id="chat-toggle">üí¨</button>

    <script>
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // ========== CHAT FUNCTIONALITY ==========

        // Store selected text for the next message
        let pendingSelectedText = null;

        // Get book-specific localStorage key for chat history
        function getChatHistoryKey() {
            return `chat_history_{{ book_id }}`;
        }

        // Save chat history to localStorage
        function saveChatHistory() {
            const messagesDiv = document.getElementById('chat-messages');
            const messages = [];

            messagesDiv.querySelectorAll('.chat-message').forEach(msg => {
                const bubble = msg.querySelector('.message-bubble');
                const type = msg.classList.contains('user') ? 'user' :
                            msg.classList.contains('ai') ? 'ai' : 'system';
                messages.push({
                    type: type,
                    content: bubble.textContent
                });
            });

            localStorage.setItem(getChatHistoryKey(), JSON.stringify(messages));
        }

        // Load chat history from localStorage
        function loadChatHistory() {
            const savedHistory = localStorage.getItem(getChatHistoryKey());
            if (savedHistory) {
                try {
                    const messages = JSON.parse(savedHistory);
                    const messagesDiv = document.getElementById('chat-messages');

                    // Clear welcome message
                    messagesDiv.innerHTML = '';

                    // Restore messages
                    messages.forEach(msg => {
                        addMessageToDOM(msg.content, msg.type, false); // false = don't save
                    });
                } catch (e) {
                    console.error('Failed to load chat history:', e);
                }
            }
        }

        // Clear chat history for current book
        function clearChatHistory() {
            localStorage.removeItem(getChatHistoryKey());
            const messagesDiv = document.getElementById('chat-messages');
            messagesDiv.innerHTML = `
                <div class="chat-message system">
                    <div class="message-bubble">
                        Ê≠°Ëøé‰ΩøÁî® AI ËÅäÂ§©Âä©ÊâãÔºÅË´ãÂÖàË®≠ÂÆö Gemini API KeyÔºåÁÑ∂ÂæåÂ∞±ÂèØ‰ª•ÈñãÂßãË®éË´ñÈÄôÊú¨Êõ∏‰∫Ü„ÄÇ
                    </div>
                </div>
            `;
        }

        // Toggle chat sidebar
        function toggleChat() {
            const sidebar = document.getElementById('chat-sidebar');
            const toggleBtn = document.getElementById('chat-toggle');
            sidebar.classList.toggle('collapsed');
            toggleBtn.classList.toggle('active');

            // Save sidebar state
            saveSidebarState();
        }

        // Save sidebar open/closed state
        function saveSidebarState() {
            const sidebar = document.getElementById('chat-sidebar');
            const isOpen = !sidebar.classList.contains('collapsed');
            localStorage.setItem('chat_sidebar_open', isOpen ? 'true' : 'false');
        }

        // Load sidebar state
        function loadSidebarState() {
            const isOpen = localStorage.getItem('chat_sidebar_open') === 'true';
            const sidebar = document.getElementById('chat-sidebar');
            const toggleBtn = document.getElementById('chat-toggle');

            if (isOpen) {
                sidebar.classList.remove('collapsed');
                toggleBtn.classList.add('active');
            } else {
                sidebar.classList.add('collapsed');
                toggleBtn.classList.remove('active');
            }
        }

        // Save API Key to localStorage
        function saveApiKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            if (!apiKey) {
                showStatus('Ë´ãËº∏ÂÖ• API Key', 'error');
                return;
            }

            localStorage.setItem('gemini_api_key', apiKey);
            showStatus('API Key Â∑≤ÂÑ≤Â≠òÔºÅ', 'success');
            document.getElementById('api-key-input').value = '';
        }

        // Load API Key from localStorage on page load
        function loadApiKey() {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (apiKey) {
                showStatus('API Key Â∑≤ËºâÂÖ•', 'success');
            }
        }

        // Save model selection to localStorage
        function saveModelSelection() {
            const modelSelect = document.getElementById('model-select');
            const selectedModel = modelSelect.value;
            localStorage.setItem('gemini_model', selectedModel);
            showStatus(`Ê®°ÂûãÂ∑≤ÂàáÊèõËá≥ ${modelSelect.options[modelSelect.selectedIndex].text}`, 'success');
        }

        // Load model selection from localStorage
        function loadModelSelection() {
            const savedModel = localStorage.getItem('gemini_model');
            if (savedModel) {
                const modelSelect = document.getElementById('model-select');
                modelSelect.value = savedModel;
            }
        }

        // Show status message
        function showStatus(message, type) {
            const statusDiv = document.getElementById('settings-status');
            statusDiv.textContent = message;
            statusDiv.style.color = type === 'success' ? '#28a745' : '#dc3545';
            setTimeout(() => {
                statusDiv.textContent = '';
            }, 3000);
        }

        // Add message to DOM (internal function)
        function addMessageToDOM(content, type, shouldSave = true) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;

            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = content;

            messageDiv.appendChild(bubble);
            messagesDiv.appendChild(messageDiv);

            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Save to localStorage if requested
            if (shouldSave) {
                saveChatHistory();
            }
        }

        // Add message to chat (public function)
        function addMessage(content, type) {
            addMessageToDOM(content, type, true);
        }

        // Send message to AI
        async function sendMessage(event) {
            event.preventDefault();

            const input = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-btn');
            const timeoutIndicator = document.getElementById('timeout-indicator');
            const message = input.value.trim();

            if (!message) return;

            // Check if API key exists
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                addMessage('Ë´ãÂÖàË®≠ÂÆö Gemini API Key', 'system');
                return;
            }

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;
            sendBtn.classList.add('loading');
            sendBtn.textContent = '';

            // Add user message
            addMessage(message, 'user');
            input.value = '';

            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutDuration = 60000; // 60 seconds timeout
            let timeoutId = null;

            // Set up timeout
            timeoutId = setTimeout(() => {
                controller.abort();
            }, timeoutDuration);

            // Show countdown
            let remainingTime = timeoutDuration / 1000;
            const countdownInterval = setInterval(() => {
                remainingTime--;
                if (remainingTime > 0) {
                    timeoutIndicator.textContent = `‚è±Ô∏è Á≠âÂæÖÂõûÊáâ‰∏≠... (${remainingTime}ÁßíÂæåË∂ÖÊôÇ)`;
                }
            }, 1000);

            try {
                // Get selected model
                const modelSelect = document.getElementById('model-select');
                const selectedModel = modelSelect.value;

                // Prepare request body
                const requestBody = {
                    message: message,
                    book_id: '{{ book_id }}',
                    chapter_index: {{ chapter_index }},
                    api_key: apiKey,
                    model_name: selectedModel
                };

                // Add selected text if available
                if (pendingSelectedText) {
                    requestBody.selected_text = pendingSelectedText;
                    pendingSelectedText = null; // Clear after sending
                }

                // Send to backend API with timeout
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                // Clear timeout and countdown
                clearTimeout(timeoutId);
                clearInterval(countdownInterval);
                timeoutIndicator.textContent = '';

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.error) {
                    addMessage(`ÈåØË™§: ${data.error}`, 'system');
                } else {
                    addMessage(data.response, 'ai');
                }

                // Clear selection after successful send
                clearSelection();

            } catch (error) {
                // Clear timeout and countdown
                clearTimeout(timeoutId);
                clearInterval(countdownInterval);
                timeoutIndicator.textContent = '';

                console.error('Chat error:', error);

                if (error.name === 'AbortError') {
                    addMessage('‚ö†Ô∏è Ë´ãÊ±ÇË∂ÖÊôÇÔºàË∂ÖÈÅé60ÁßíÔºâ„ÄÇË´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑öÊàñÁ®çÂæåÂÜçË©¶„ÄÇ', 'system');
                } else {
                    addMessage(`ÁôºÁîüÈåØË™§: ${error.message}`, 'system');
                }
            } finally {
                // Re-enable input
                input.disabled = false;
                sendBtn.disabled = false;
                sendBtn.classList.remove('loading');
                sendBtn.textContent = 'ÁôºÈÄÅ';
                timeoutIndicator.textContent = '';
                input.focus();
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadApiKey();
            loadModelSelection();
            loadSidebarState();
            loadChatHistory();
            initTextSelection();
            initChatResizer();
            loadChatWidth();
        });

        // ========== CHAT RESIZER FUNCTIONALITY ==========

        function initChatResizer() {
            const resizer = document.getElementById('chat-resizer');
            const sidebar = document.getElementById('chat-sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                sidebar.classList.add('resizing');
                resizer.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = startX - e.clientX;
                const newWidth = startWidth + deltaX;

                // Enforce min and max width
                const minWidth = 280;
                const maxWidth = 600;
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                sidebar.style.width = constrainedWidth + 'px';
                sidebar.style.setProperty('--chat-width', constrainedWidth + 'px');
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    sidebar.classList.remove('resizing');
                    resizer.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Save width to localStorage
                    saveChatWidth(sidebar.offsetWidth);
                }
            });
        }

        function saveChatWidth(width) {
            localStorage.setItem('chat_sidebar_width', width);
        }

        function loadChatWidth() {
            const savedWidth = localStorage.getItem('chat_sidebar_width');
            if (savedWidth) {
                const sidebar = document.getElementById('chat-sidebar');
                const width = parseInt(savedWidth);
                sidebar.style.width = width + 'px';
                sidebar.style.setProperty('--chat-width', width + 'px');
            }
        }

        // ========== TEXT SELECTION FUNCTIONALITY ==========

        let selectedText = '';
        let savedRange = null; // Save the Range object to restore selection

        function initTextSelection() {
            const contentArea = document.querySelector('.book-content');
            const chatSidebar = document.getElementById('chat-sidebar');
            const chatInput = document.getElementById('chat-input');

            // Listen for text selection
            document.addEventListener('mouseup', (e) => {
                // Don't process if clicking inside chat sidebar
                if (chatSidebar.contains(e.target)) {
                    return;
                }

                // Small delay to ensure selection is complete
                setTimeout(() => {
                    const selection = window.getSelection();
                    const text = selection.toString().trim();

                    if (text && text.length > 0) {
                        // Check if selection is within book content
                        const range = selection.getRangeAt(0);
                        const container = range.commonAncestorContainer;
                        const isInContent = contentArea.contains(container.nodeType === 3 ? container.parentNode : container);

                        if (isInContent) {
                            selectedText = text;
                            pendingSelectedText = text;
                            savedRange = range.cloneRange(); // Save the range
                            showSelectionIndicator(text.length);
                        } else {
                            // Clicked outside book content (but not in chat sidebar)
                            clearSelection();
                        }
                    } else {
                        // No text selected, clear if clicked outside chat sidebar
                        clearSelection();
                    }
                }, 10);
            });

            // Restore selection when clicking away from chat input
            chatSidebar.addEventListener('mousedown', (e) => {
                // If we have a saved selection, restore it after a short delay
                if (savedRange) {
                    setTimeout(() => {
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(savedRange);
                    }, 50);
                }
            });

            // Also listen for clicks to clear selection when clicking outside
            document.addEventListener('mousedown', (e) => {
                // If clicking in chat sidebar, keep selection
                if (chatSidebar.contains(e.target)) {
                    return;
                }

                // If clicking in book content area, might be starting a new selection
                if (contentArea.contains(e.target)) {
                    return;
                }

                // Clicking elsewhere (TOC, etc.) - clear selection
                clearSelection();
            });
        }

        function showSelectionIndicator(charCount) {
            const indicator = document.getElementById('selection-indicator');
            const indicatorText = document.getElementById('selection-indicator-text');
            indicatorText.textContent = `üìù Â∑≤ÈÅ∏Âèñ ${charCount} Â≠ó - Âú®‰∏ãÊñπËº∏ÂÖ•ÂïèÈ°åÂç≥ÂèØË®éË´ñÊ≠§ÊÆµËêΩ`;
            indicator.classList.add('active');
        }

        function hideSelectionIndicator() {
            const indicator = document.getElementById('selection-indicator');
            indicator.classList.remove('active');
        }

        function clearSelection() {
            selectedText = '';
            pendingSelectedText = null;
            savedRange = null;
            hideSelectionIndicator();
            window.getSelection().removeAllRanges();
        }
    </script>
</body>
</html>
